<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小虫子O o o</title>
  
  <subtitle>生命也许会孤独一阵子，但不会孤独一辈子</subtitle>
  <link href="http://tsung1992.github.io/atom.xml" rel="self"/>
  
  <link href="http://tsung1992.github.io/"/>
  <updated>2025-11-14T14:37:21.240Z</updated>
  <id>http://tsung1992.github.io/</id>
  
  <author>
    <name>tsung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://tsung1992.github.io/hello-world/"/>
    <id>http://tsung1992.github.io/hello-world/</id>
    <published>2025-11-14T14:37:21.239Z</published>
    <updated>2025-11-14T14:37:21.240Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VRRP-虚拟路由器冗余协议</title>
    <link href="http://tsung1992.github.io/network/VVRP/"/>
    <id>http://tsung1992.github.io/network/VVRP/</id>
    <published>2021-12-21T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>VRRP(Virtual Router Redundancy Protocol，虚拟路由器冗余协议)。可以使多台同属于同一个广播域的网络设备能够协同工作，实现设备冗余，提高网络的可靠性。</p><p>版本：</p><ul><li>VRRPv2：仅适用于IPv4网络</li><li>VRRPv3：适用于IPv4及IPv6网络</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="1-VRRP路由器"><a href="#1-VRRP路由器" class="headerlink" title="1. VRRP路由器"></a>1. VRRP路由器</h4><p>将运行VRRP的路由器成为VRRP路由器。当路由器启动VRRP功能后，会产生一台虚拟路由器。VRRP是配置在路由器的接口中，同时也是基于接口进行工作的。当激活VRRP时，路由器的接口编开始发送和侦听VRRP协议报文。</p><blockquote><p>注意：协同工作的VRRP路由器必须属于同一个广播域，否则VRRP报文无法正常进行交互。</p></blockquote><h4 id="2-VRRP组及VRID"><a href="#2-VRRP组及VRID" class="headerlink" title="2. VRRP组及VRID"></a>2. VRRP组及VRID</h4><ul><li><p>一个VRRP组(VRRP Group)是由多台协同工作的路由器组成，使用相同的VRID(Virtual Router Identifier，虚拟路由器标识符)进行标识。</p></li><li><p>一个VRRP组只能出现一个Master设备</p></li><li><p>属于同一个VRRP组的路由器之间交互VRRP协议报文并产生一台虚拟路由器</p></li><li><p>一个接口可以加入单个VRRP组，也可以加入多个VRRP组</p></li><li><p>不同VRRP组通过不同的VRID 进行区分</p></li></ul><h4 id="3-虚拟路由器、虚拟IP地址及虚拟MAC地址"><a href="#3-虚拟路由器、虚拟IP地址及虚拟MAC地址" class="headerlink" title="3. 虚拟路由器、虚拟IP地址及虚拟MAC地址"></a>3. 虚拟路由器、虚拟IP地址及虚拟MAC地址</h4><ul><li>虚拟路由器：<ul><li>由VRRP虚拟出的逻辑设备。非真实存在的物理设备。</li><li>一个VRRP组仅会产生一台虚拟路由器</li></ul></li><li>虚拟IP地址：<ul><li>虚拟路由器的IP地址，由网络管理员配置VRRP时指定，通常作为网关IP地址。</li><li>一台虚拟路由器可以有一个或多个IP地址</li><li>通常情况下，虚拟IP地址不会与接口IP地址重叠</li><li>当某台虚拟路由器的接口IP地址用于虚拟路由器时，该虚拟路由器将无条件成为Master  (当Master Down时，backup会接管这个IP地址)</li></ul></li><li>虚拟MAC地址：<ul><li>格式：<strong>0000-5e00-01xx</strong>，其中xx为VRID，如：当VRID 为1时，虚拟MAC 地址为：0000-5e00-0101</li><li>当master路由器收到请求虚拟路由器MAC地址的ARP Requests时，在ARP Reply中回应的MAC地址为虚拟MAC地址</li></ul></li></ul><h4 id="4-Master路由器、Backup路由器"><a href="#4-Master路由器、Backup路由器" class="headerlink" title="4. Master路由器、Backup路由器"></a>4. Master路由器、Backup路由器</h4><ul><li>Master路由器：<ul><li>主路由器，接口处于Master状态</li><li>承担报文转发任务</li><li>只有Master才会响应针对虚拟IP地址的ARP Request，以虚拟MAC地址进行回应</li><li>转发目的MAC地址为虚拟MAC地址的报文</li><li>在一定时间间隔中，发送ARRP报文，以通知其他路由器关于自己的存活状态</li></ul></li><li>Backup路由器：<ul><li>备份路由器</li><li>实时侦听Master路由器发送的VRRP报文</li><li>对关于VRRP虚拟IP地址的ARP请求不予回应</li><li>丢弃目的MAC地址为VRRP虚拟MAC地址的数据帧</li><li>不接收目的IP地址为VRRP虚拟IP地址的数据包</li></ul></li><li>选举条件：<ul><li>优先级越大，越有可能成为Master路由器</li><li>相同优先级，接口IP地址越大，越有可能成为Master路由器</li></ul></li></ul><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><h4 id="1-报文格式"><a href="#1-报文格式" class="headerlink" title="1. 报文格式"></a>1. 报文格式</h4><p>VRRP 定义了一种报文格式，即通告报文。被封装在IP报文中。IP头部协议号字段值为112，报文的目的IP地址为组播地址224.0.0.18。</p><p>**备注：**224.0.0.18为本地范围的多播地址，不论TTL的值未多少，路由器均被禁止转发此地址为目的地址的报文。</p><p>报文格式：</p><p><img src= "/img/loading.gif" data-lazy-src="/images/vrrp-format.png" alt="img"></p><p>格式说明：</p><table><thead><tr><th>字段</th><th>长度</th><th>说明</th></tr></thead><tbody><tr><td>Version</td><td>4</td><td>指定VRRP协议版本</td></tr><tr><td>Type</td><td>4</td><td>定义VRRP报文类型。该字段值恒为1</td></tr><tr><td>虚拟路由器ID(VRID)</td><td>8</td><td>虚拟路由器的标识符，取值范围1-255</td></tr><tr><td>Priority(优先级)</td><td>8</td><td>该值越大，则VRRP优先级越高，越有可能成为Master，取值范围0-255<br>255：当VRRP路由器是虚拟路由器IP地址的所有者时，优先级必须为255 <br>0：用于指示当前虚拟路由器的主路由器停止参与VRRP组</td></tr><tr><td>IP地址个数</td><td>8</td><td>VRRP组中虚拟IP地址的个数。</td></tr><tr><td>Auth Type（认证类型）</td><td>8</td><td>该字段为0时，表示无认证<br>该字段为1时，表示明文认证方式<br>该字段为2时，表示MD5认证方式</td></tr><tr><td>Adver Int（通告间隔）</td><td>8</td><td>VRRP报文的发送时间间隔（单位秒）</td></tr><tr><td>校验和</td><td>16</td><td>用于检测VRRP消息的数据是否出错<br>校验和是从version字段开始的整个VRRP消息的1的16位补码和</td></tr></tbody></table><h4 id="2-状态机"><a href="#2-状态机" class="headerlink" title="2. 状态机"></a>2. 状态机</h4><blockquote><ul><li><p>初始状态(initialize)</p><p>是VRRP的初始状态。在接口配置VRRP后，如果该接口是Down的，那么该接口的VRRP状态将会停滞在Initailize状态</p></li><li><p>Backup(备份状态)</p><p>备份路由器所处的状态</p></li><li><p>Master(主状态)</p><p>主路由器所处的状态</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;VRRP(Virtual Router Redundancy Protocol，虚拟路由器冗余协议)。可以使多台同属于同一个广播域的网络设备</summary>
      
    
    
    
    <category term="HCNP路由交换" scheme="http://tsung1992.github.io/categories/HCNP%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"/>
    
    
    <category term="路由交换" scheme="http://tsung1992.github.io/tags/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/"/>
    
    <category term="网络基础" scheme="http://tsung1992.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JSON WEB TOKEN</title>
    <link href="http://tsung1992.github.io/http/JWT/"/>
    <id>http://tsung1992.github.io/http/JWT/</id>
    <published>2021-11-14T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是JWT"><a href="#1-什么是JWT" class="headerlink" title="1. 什么是JWT"></a>1. 什么是JWT</h2><blockquote><p>Json web token(JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准(<a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a>)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其他业务逻辑所必须的声明信，可以被直接用于认证，也可被加密。</p></blockquote><h2 id="2-JWT组成"><a href="#2-JWT组成" class="headerlink" title="2. JWT组成"></a>2. JWT组成</h2><p>JWT由三部分组成：<strong>Base64.encode(header).Base64(payload).签名值</strong></p><ul><li><p>header头部</p><blockquote><ul><li>声明类型，即JWT</li><li>声明加密算法，同时直使用HMAC SHA256</li></ul></blockquote></li><li><p>Payload - jwt存放的数据 【注意不能存放敏感数据】</p><blockquote><ul><li>标准中注册的声明(建议但不强制使用)</li><li>iss：JWT签发者</li><li>sub：JWT所面向的用户</li><li>aud：接收JWT的一方</li><li>exp：JWT的过期时间，过期时间必须大于签发时间</li><li>iat：JWT的签发时间</li><li>jti：JWT的唯一身份标识，主要用来作为一词性token，从而回避重放攻击</li><li>公共的声明</li><li>可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。</li><li>私有的声明</li><li>是提供者和消费者所共同定义的声明，一般不建议存放敏感信息。</li></ul></blockquote></li><li><p>Payload采用md5加密之后的签名值</p></li></ul><h2 id="3-JWT示例："><a href="#3-JWT示例：" class="headerlink" title="3. JWT示例："></a>3. JWT示例：</h2><blockquote><p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20211115222103222.png" alt="img"></p></blockquote><h2 id="4-JWT作用"><a href="#4-JWT作用" class="headerlink" title="4. JWT作用"></a>4. JWT作用</h2><p>JWT初衷是为了实现授权和身份认证作用，可以实现无状态、分布式的Web应用授权。</p><blockquote><ul><li><strong>Authentication（鉴权）</strong>：<br>这是使用JWT最常见的情况。 一旦用户登录，每个后续请求都将包含JWT，允许用户访问该令牌允许的路由，服务和资源。 单点登录是当今广泛使用JWT的一项功能，因为它的开销很小，并且能够轻松地跨不同域使用。</li><li><strong>Information Exchange（信息交换）</strong>：<br>JSON Web Tokens是在各方之间安全传输信息的好方式。 因为JWT可以签名：例如使用公钥&#x2F;私钥对，所以可以确定发件人是他们自称的人。 此外，由于使用标头和有效载荷计算签名，因此您还可以验证内容是否未被篡改。</li></ul></blockquote><p>JWT主要流程如下：</p><p><img src= "/img/loading.gif" data-lazy-src="/images/CNaact.png" alt="img"></p><h2 id="5-与传统session区别"><a href="#5-与传统session区别" class="headerlink" title="5. 与传统session区别"></a>5. 与传统session区别</h2><h3 id="5-1-传统session"><a href="#5-1-传统session" class="headerlink" title="5.1 传统session"></a>5.1 传统session</h3><p>HTTP本身是一种无状态协议，即意味着如果用户向应用提供了用户名和密码进行认证，认证通过后HTTP协议不会记录认证后的状态，因此在下一次请求时，用户还需再进行一次认证，依据HTTP协议，为了使应用能够识别是哪个用户发出的请i去，只能在客户首次登录成功后，在服务器存储一用户登录的信息，该登录信息会在响应时传递给浏览器，即Set-Cookie，以便下次请求时发送给应用，应用可更具请求中携带的Cookie识别该请求来自哪个用户。</p><p>传统session认证缺点：</p><ul><li>随着用户增多，服务器开销会明显增大（每个用户的登录信息都会保存到服务session中）</li><li>由于session时存在于服务器的物理内存中，所在不适用分布式服务器</li><li>非 浏览器的客户端、手机移动端等不适用</li><li>由于session认证本质基于cookie，当发生 cookie</li><li>劫持后，用户很容易受到跨站请i去伪造攻击</li><li>由于基于Cookie，而Cookie无法跨域，所以session的认证也无法跨域，对单点登录不适用</li></ul><h3 id="5-2-JWT优势"><a href="#5-2-JWT优势" class="headerlink" title="5.2 JWT优势"></a>5.2 JWT优势</h3><ul><li>简洁，JWT Token数据量小，传输速度也很快</li><li>由于JWT Token是以JSON加密形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持</li><li>不依赖于cookie和session，所以没有了传统session认证的弊端，适用于分布式微服务</li><li>单点登录友好，token可以被保存在客户端的任意位置的内存中，不一定是cookie，所以不依cookie</li><li>适合移动端应用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是JWT&quot;&gt;&lt;a href=&quot;#1-什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是JWT&quot;&gt;&lt;/a&gt;1. 什么是JWT&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Json web token(JWT)，是为了在网络应用环境间</summary>
      
    
    
    
    <category term="HTTP" scheme="http://tsung1992.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://tsung1992.github.io/tags/HTTP/"/>
    
    <category term="WEB" scheme="http://tsung1992.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>Internet地址结构</title>
    <link href="http://tsung1992.github.io/network/Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/"/>
    <id>http://tsung1992.github.io/network/Internet%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IP地址–通用标识符</p><ul><li>唯一标识互联网上的主机或路由器(唯一、通用、网络连接)</li></ul><p>主机标识符</p><ul><li>name：是什么，可读性强</li><li>address：在哪里，软件效率高</li><li>route：如何达到</li></ul><h2 id="IP地址表示"><a href="#IP地址表示" class="headerlink" title="IP地址表示"></a>IP地址表示</h2><h4 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h4><ul><li>长度为32 bit</li><li>采用所谓的点分四组或点分十进制表示法</li><li>每个数字是一个非负整数，范围为[0-255]，代表整个IP地址的四分之一</li></ul><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><ul><li>长度为128 bit</li><li>IPv6地址的传统表示方法为采用称为块或字段的4个十六进制数，这些称为块或字段的数由&#x3D;&#x3D;冒号&#x3D;&#x3D;分隔</li></ul><p>IPv6地址简化表示：</p><ul><li>一个块中前导的零必须压缩</li><li>全零的块可以省略，并用符号::代替(::只能用于影响最大的地方，压缩最多的零)，一个IPv6地址中只能使用一次::符号</li><li>在IPv6格式中嵌入IPv4地址可使用混合符号形式，紧接着IPv4部分的地址块的值为ffff，地址的其余部分使用点分四组格式(IPv4映射的IPv6地址)【::ffff:10.0.0.1 –&gt; 10.0.0.1】</li><li>IPv6地址的低32位通常采用点分四组表示法（IPv4兼容的IPv6）【::0102:f001 –&gt; 1.2.240.1】</li><li>a到f的16进制数字应该用小写表示</li></ul><h2 id="IP地址结构"><a href="#IP地址结构" class="headerlink" title="IP地址结构"></a>IP地址结构</h2><h3 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h3><p>IP地址组成：网络部分和主机部分</p><blockquote><ul><li>网络部分：用于识别接口使用的IP地址在哪个网络中发现</li><li>主机地址：用于识别由网络部分给出的网络中的特定主机</li></ul></blockquote><p>地址中的一些连续位称为网络号，其余称为主机号。</p><p><img src= "/img/loading.gif" data-lazy-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2681518048,2999374401&fm=26&gp=0.jpg" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200719202429136.png" alt="image-20200719202429136"></p><p>用于表示通信节点的IP地址为A、B、C三类，用于为Internet(单播地址)中的接口分配地址</p><p>D：供组播使用</p><p>E：保留地址</p><h2 id="特殊网络地址"><a href="#特殊网络地址" class="headerlink" title="特殊网络地址"></a>特殊网络地址</h2><table><thead><tr><th>特殊地址</th><th>Net id</th><th>Host ID</th><th>源&#x2F;目的地址</th></tr></thead><tbody><tr><td>网络地址</td><td>特定的</td><td>全0</td><td>都不是</td></tr><tr><td>直接广播地址</td><td>特定的</td><td>全1</td><td>目的地址</td></tr><tr><td>受限广播地址</td><td>全1</td><td>全1</td><td>目的地址</td></tr><tr><td>本网络上的本主机</td><td>全0</td><td>全0</td><td>源地址(0.0.0.0)</td></tr><tr><td>本网络上的特定主机</td><td>全0</td><td>特定的</td><td>目的地址</td></tr><tr><td>环回地址</td><td>127</td><td>任意</td><td>目的主机</td></tr></tbody></table><p> 网络地址：仅用于标识网络，而不标识网络内的任意节点，标识的是一个网络集合</p><p>直接广播地址：标识对特定网络的广播</p><p>受限广播地址(本地广播地址)：标识对本地网络的广播</p><p>本网络上的特定主机：仅可作为源地址，获取自己的IP地址而临时使用的IP地址</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码是由一台主机或路由器使用的分配位，以确定如何从一台主机对应IP地址中获取网络和子网信息。</p><p>掩码由路由器和主机使用，以&#x3D;&#x3D;确定一个IP地址的网络&#x2F;子网部分的结束和主机部分的开始。&#x3D;&#x3D;</p><ul><li>表示网络或子网的大小</li><li>32 bits 二进制数</li><li>1表示一个IP地址的对应位与一个地址的网络&#x2F;子网部分的对应位集合</li><li>0表示一个IP地址的对应位作为主机ID的一部分</li></ul><h2 id="可变长度子网掩码"><a href="#可变长度子网掩码" class="headerlink" title="可变长度子网掩码"></a>可变长度子网掩码</h2><p>VSLM(可变长度子网掩码)：用于分割一个网络号，使每个子网支持不同数量的主机。提高子网结构的灵活性</p><h3 id="如何确定可变子网长度？"><a href="#如何确定可变子网长度？" class="headerlink" title="如何确定可变子网长度？"></a>如何确定可变子网长度？</h3><p>确定可变子网掩码长度的过程其实就是划分子网的过程。</p><p>当从主机位中借1位二进制位时，当前网络可划分出2个子网，每个子网主机数是原来的1&#x2F;2-2；当从主机位中借2位二进制位时，当前网络可划分出4个子网，每个子网主机数是原来的1&#x2F;4-2……当从主机位中借N位二进制位时，当前网络可划分为2N个子网，每个子网主机数是原来的2-N-2</p><p>192.168.10.0&#x2F;24这个C类网络要划分出2个相等主机数的子网，则</p><ol><li><p>网络号与子网掩码转为二进制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">网络号  192.168.10.0  转为二进制 11000000 10101000  00001010 00000000</span><br><span class="line">子网掩码 255.255.255.0  转为二进制 11111111 11111111  11111111 00000000</span><br></pre></td></tr></table></figure></li><li><p>要把一个网络划分成两个相等子网，子网掩码要加1位，变成11111111 11111111  11111111 10000000</p></li><li><p>网络号从主机位借一位用于子网11000000 10101000  00001010 XYYYYYYY</p><p>X位代表借入的，用于表示子网号，7个Y代表剩余主机位，X有两个值0和1。</p><p>1）为0时：</p><p>​        11000000 10101000  00001010 0YYYYYYY </p><p>​        当Y全为0，表示划分出的这个子网的网络号，为11000000 10101000  00001010 00000000</p><p>​        其主机可用IP地址范围是：</p><p>​        11000000 10101000 00001010 0 0000001（192.168.10.1，掩码：255.255.255.128）</p><p>​        至</p><p>​        11000000 10101000  00001010 0 1111110（192.168.10.126，掩码：255.255.255.128）</p><p>2）为1时</p><p>​        11000000 10101000  00001010 1YYYYYYY</p><p>​        当Y全为0，表示划分出的这个子网的网络号，为11000000 10101000  00001010 10000000</p><p>​        其主机可用IP地址范围是：</p><p>​        11000000 10101000  00001010 1 0000001（192.168.10.129，掩码：255.255.255.128）</p><p>​        至</p><p>​        11000000 10101000  00001010 1 1111110（192.168.10.254，掩码：255.255.255.128）</p><p>综述，192.168.10.0&#x2F;24要划分成两个相等主机数的子网，子网掩码要改为25位，划分出的两个子网情况是：</p><p>子网1：</p><p>网络号：192.168.10.0    子网掩码：255.255.255.128    广播地址：192.168.10.127</p><p>主机IP地址范围：192.168.10.1至192.168.10.126</p><p>子网2：</p><p> 网络号：192.168.10.128    子网掩码：255.255.255.128    广播地址：192.168.10.255</p><p> 主机IP地址范围：192.168.10.129至192.168.10.254</p></li></ol><h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><ol><li><p>定向广播地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 通过子网掩码取反与IP地址按位或运算得到</span><br><span class="line">2. 可作为一个单独的数据报通过Internet路由直至到达目标子网，再作为一组数据报发送给子网中所有主机</span><br><span class="line">* 由于安全问题，其在Internet中被禁用</span><br></pre></td></tr></table></figure></li><li><p>本地网络广播(有限广播)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 特殊地址：255.255.255.255</span><br><span class="line">2. 不会被路由器转发,链路层的广播机制用于支持它们</span><br><span class="line">3. 广播地址可用于IPv4中，而IPv6仅使用组播地址</span><br></pre></td></tr></table></figure></li></ol><h2 id="IPv6地址和接口标识符"><a href="#IPv6地址和接口标识符" class="headerlink" title="IPv6地址和接口标识符"></a>IPv6地址和接口标识符</h2><p>IPv6特点：</p><ul><li>一个IPv6地址范围指其可用的网络规模</li><li>节点本地(只用于同一计算机通信)</li><li>链路本地(只用于同一网络链路或IPv6前缀中的结点)</li><li>全球性(Internet范围)</li><li>IPv6中，大部分节点通常在同一网络接口上使用多个地址</li><li>一个IPv6节点需要一组地址，包括组播地址</li></ul><p>链路本地IPv6地址使用接口标识符(IID)作为一个单播IPv6地址的分配基础。</p><p>IID的长度通常为64位，并直接由一个网络接口相关的链路层MAC地址形成，该地址使用修改的EUI-64格式或由其他进程随机提供的值形成，以提供可防范地址跟踪的某种程度的隐私保护。</p><p>EUI表示扩展唯一标识符</p><p>EUI-64标识符由一个24位的组织唯一标识符(OUI)+组织分配的40位可扩展标识符组成，并由前24位识别。</p><p>OUI由IEEE注册权威机构维护并分配。长度为24位，并占据EUI-48和EUI-64地址的前3个字节。该地址的第一个字节的低两位分别为u位和g位。当u位被设置时，表示该地址是本地管理，当g位被设置时，表示该地址是一组或组播类型的地址。</p><p>EUI-64计算方法：</p><ul><li>由EUI-48地址形成</li><li>将EUI-48地址的24位OUI复制到EUI-64地址</li><li>EUI-64地址的4，5字节的16位替换为FFFE</li><li>复制由组织分配的剩余位</li></ul><p>修改的EUI-64用于形成IPv6地址的IID，但需要对u位取反。</p><p>链路本地IPv6地址计算方法：</p><ol><li><p>查看接口MAC地址：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eth0      Link encap:Ethernet  HWaddr 00:50:56:9d:a3:b4  </span><br><span class="line">          inet addr:10.160.14.61  Bcast:10.160.14.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::250:56ff:fe9d:a3b4/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:147710806 errors:2 dropped:3659 overruns:0 frame:0</span><br><span class="line">          TX packets:158983119 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:9252586604 (9.2 GB)  TX bytes:35110783086 (35.1 GB)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>变换为EUI-64，MAC地址前三节不变，第4，5节插入fffe(固定的)，并复制剩余位</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00:50:56:ff:fe:9d:a3:b4</span><br></pre></td></tr></table></figure></li><li><p>u位取反（第一节内容：0000 0000，后两位分别为0）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000 0000:50:56:ff:fe:9d:a3:b4</span><br><span class="line">u位取反：</span><br><span class="line">0000 0010:50:56:ff:fe:9d:a3:b4</span><br></pre></td></tr></table></figure></li><li><p>形成的IID为：02:50:56:ff:fe:9d:a3:b4</p></li><li><p>使用保留的链路本地前缀fe80:&#x2F;10，形成完整地址，&#x2F;64为标准长度，用于一个IPv6地址中识别子网&#x2F;主机部分：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fe80:250:56ff:fe9d:a3b4</span><br></pre></td></tr></table></figure></li></ol><h2 id="CIDR和聚合"><a href="#CIDR和聚合" class="headerlink" title="CIDR和聚合"></a>CIDR和聚合</h2><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>无类别域间路由(CIDR)</p><h2 id="单播-多播-广播地址"><a href="#单播-多播-广播地址" class="headerlink" title="单播&#x2F;多播&#x2F;广播地址"></a>单播&#x2F;多播&#x2F;广播地址</h2><h3 id="单播-Unicast"><a href="#单播-Unicast" class="headerlink" title="单播(Unicast)"></a>单播(Unicast)</h3><ul><li>通信：一对一，源或目的地址</li><li>因特网上的所有系统必须至少有一个唯一的单播地址</li><li>可以为A、B或C类</li></ul><h3 id="多播-Multicast"><a href="#多播-Multicast" class="headerlink" title="多播(Multicast)"></a>多播(Multicast)</h3><ul><li>通信：一对多，目的地址</li><li>因特网上的系统可以由一个或多个多播地址</li><li>只能是D类，本地级(本IP网络内的一组通信节点)或全局级</li></ul><h3 id="广播-Broadcast"><a href="#广播-Broadcast" class="headerlink" title="广播(Broadcast)"></a>广播(Broadcast)</h3><ul><li>通信：一对所有，目的地址</li><li>受限广播或直接广播，本地级</li></ul><table><thead><tr><th>类</th><th>地址范围</th><th>高序位</th><th>用途</th><th>百分比</th><th>网络数</th><th>主机数</th></tr></thead><tbody><tr><td>A</td><td>0.0.0.0-127.255.255.255</td><td>0</td><td>单播&#x2F;特殊</td><td>1&#x2F;2</td><td>128（126）</td><td>1677216</td></tr><tr><td>B</td><td>128.0.0.0-191.255.255.255</td><td>10</td><td>单播&#x2F;特殊</td><td>1&#x2F;4</td><td>16384</td><td>65536</td></tr><tr><td>C</td><td>192.0.0.0-223.255.255.255</td><td>110</td><td>单播&#x2F;特殊</td><td>1&#x2F;8</td><td>2097152</td><td>256</td></tr><tr><td>D</td><td>224.0.0.0-239.255.255.255</td><td>1110</td><td>组播</td><td>1&#x2F;16</td><td>N&#x2F;A</td><td>N&#x2F;A</td></tr><tr><td>E</td><td>240.0.0.0-255.255.255.255</td><td>1111</td><td>保留</td><td>1&#x2F;16</td><td>N&#x2F;A</td><td>N&#x2F;A</td></tr></tbody></table><h2 id="专用网"><a href="#专用网" class="headerlink" title="专用网"></a>专用网</h2><ul><li><p>不需接入Internet，但需要用TCP&#x2F;IP通信</p></li><li><p>编址方案</p><p>​    申请，并使用A、B、C类地址(全局唯一)</p><p>​    不申请，直接使用A、B、C类地址(本组织唯一，全局不唯一)</p><p>​    不申请，直接使用专用地址(本组织唯一，全局不唯一)</p></li><li><p>专用地址(私有地址)</p></li></ul><table><thead><tr><th>类</th><th>私有地址</th><th>总数</th></tr></thead><tbody><tr><td>A</td><td>10.0.0.0-10.255.255.255</td><td>1 x A</td></tr><tr><td>B</td><td>172.16.0.0-172.31.255.255</td><td>16 x B</td></tr><tr><td>C</td><td>192.168.0.0-192.168.255.255</td><td>256 x C</td></tr></tbody></table><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>网络号：IP地址的一个组成部分</p><p>网络地址：一个IP地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;IP地址–通用标识符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一标识互联网上的主机或路由器(唯一、通用、网络连接)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主机标识</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>Internet控制报文协议</title>
    <link href="http://tsung1992.github.io/network/Internet%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/"/>
    <id>http://tsung1992.github.io/network/Internet%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:58.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>问题：</p><blockquote><ol><li>IP协议本身并没有为终端系统提供直接的方法来发现那些发往目的地址失败的IP数据包。</li><li>IP没有提供直接的方式来获取诊断信息</li></ol></blockquote><p>解决：</p><blockquote><p>ICMP：Internet控制报文协议：</p><ol><li>与IP结合使用，以便提供与IP协议层配置和IP数据包处置相关的诊断和控制信息</li><li>ICMP不为IP网络提供可靠性，表明了某些类别的故障和配置信息</li></ol></blockquote><h2 id="ICMP在IPv4和IPv6中的封装"><a href="#ICMP在IPv4和IPv6中的封装" class="headerlink" title="ICMP在IPv4和IPv6中的封装"></a>ICMP在IPv4和IPv6中的封装</h2><h3 id="IPv4："><a href="#IPv4：" class="headerlink" title="IPv4："></a>IPv4：</h3><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200727230008685.png" alt="image-20200727230008685"></p><h3 id="IPv6："><a href="#IPv6：" class="headerlink" title="IPv6："></a>IPv6：</h3><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200727230230929.png" alt="image-20200727230230929"></p><h3 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h3><p><img src= "/img/loading.gif" data-lazy-src="/images/201805301801365.png" alt="201805301801365.png"></p><ul><li>以8位的类型和代码字段开始</li><li>其后的16位校验和字段涵盖了整个报文</li></ul><p>ICMPv4中为类型字段保留了42个不同的值，用于确定特定的报文</p><p>ICMPv6中，将涵盖一个来自IPv6头部的伪头部(pseudo-header)</p><h2 id="ICMP报文"><a href="#ICMP报文" class="headerlink" title="ICMP报文"></a>ICMP报文</h2><p>分类：</p><blockquote><ol><li>差错报文：有关IP数据报传递的ICMP报文</li><li>查询或信息类报文：有关信息采集和配置的ICMP报文</li></ol></blockquote><h3 id="ICMPv4报文"><a href="#ICMPv4报文" class="headerlink" title="ICMPv4报文"></a>ICMPv4报文</h3><table><thead><tr><th>类型</th><th>正式名称</th><th>参考</th><th>E&#x2F;I</th><th>用途&#x2F;注释</th></tr></thead><tbody><tr><td>0(*)</td><td>回显应答</td><td>RFC0792</td><td>I</td><td>回显(ping)应答，返回数据</td></tr><tr><td>3(*)(+)</td><td>目的不可达</td><td>RFC0792</td><td>E</td><td>不可达的主机&#x2F;协议</td></tr><tr><td>4</td><td>源端抑制</td><td>RFC0792</td><td>E</td><td>表示拥塞(弃用)</td></tr><tr><td>5(*)</td><td>重定向</td><td>RFC0792</td><td>E</td><td>表示应该被使用的可选路由</td></tr><tr><td>8(*)</td><td>回显</td><td>RFC0792</td><td>I</td><td>回显(ping)请求（数据可选）</td></tr><tr><td>9</td><td>路由器通告</td><td>RFC1256</td><td>I</td><td>请求路由器通告</td></tr><tr><td>10</td><td>路由器请求</td><td>RFC1256</td><td>I</td><td>请求路由器通告</td></tr><tr><td>11(*)(+)</td><td>超时</td><td>RFC0792</td><td>E</td><td>资源耗尽(例如IPv4 TTL)</td></tr><tr><td>12(*)(+)</td><td>参数问题</td><td>RFC0792</td><td>E</td><td>有问题的数据包或头部</td></tr></tbody></table><h3 id="ICMPv6报文"><a href="#ICMPv6报文" class="headerlink" title="ICMPv6报文"></a>ICMPv6报文</h3><p>ICMPv6负责的不仅是差错和信息类报文，也负责大量IPv6路由器和主机的配置。</p><p>ICMPv6中，差错报文的报文类型从0-127，信息类报文的报文类型从128-255。</p><h3 id="处理ICMP报文"><a href="#处理ICMP报文" class="headerlink" title="处理ICMP报文"></a>处理ICMP报文</h3><p>一般情况下：</p><ol><li>传入的信息类请求将被操作系统自动处理</li><li>差错类报文传递给用户进程或传输层协议</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;IP协议本身并没有为终端系统提供直接的方法来发现那些发往目的地址失败的IP数据包</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>sqli-labs安装</title>
    <link href="http://tsung1992.github.io/SQL/sqli-labs%E4%BD%BF%E7%94%A8/"/>
    <id>http://tsung1992.github.io/SQL/sqli-labs%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker安装sqli-labs"><a href="#docker安装sqli-labs" class="headerlink" title="docker安装sqli-labs"></a>docker安装sqli-labs</h2><ol><li><p>docker search sqli-labs</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker search sqli-labs</span><br><span class="line">NAME                       DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">acgpiano/sqli-labs         sql injection labs                              12</span><br><span class="line">c0ny1/sqli-labs            sqli-labs是一个sql注入的练习靶机，项目地址为…                   2                                 </span><br></pre></td></tr></table></figure></li><li><p>docker pull acgpiano&#x2F;sqli-labs</p></li><li><p>查看镜像docker images </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">acgpiano/sqli-labs   latest              0976afc45249        4 years ago         434MB</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>运行sqli-labs</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dt --name sqli -p 8081:80 --rm acgpiano/sqli-labs</span><br></pre></td></tr></table></figure></li><li><p>通过浏览器访问：localhost:8081，显示如下页面，表示安装完成啦</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200929151237414.png" alt="image-20200929151237414"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker安装sqli-labs&quot;&gt;&lt;a href=&quot;#docker安装sqli-labs&quot; class=&quot;headerlink&quot; title=&quot;docker安装sqli-labs&quot;&gt;&lt;/a&gt;docker安装sqli-labs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;d</summary>
      
    
    
    
    <category term="SQL" scheme="http://tsung1992.github.io/categories/SQL/"/>
    
    
    <category term="sql" scheme="http://tsung1992.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>IPv6基础</title>
    <link href="http://tsung1992.github.io/network/IPv6%E5%9F%BA%E7%A1%80/"/>
    <id>http://tsung1992.github.io/network/IPv6%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-31T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IPv6基础"><a href="#IPv6基础" class="headerlink" title="IPv6基础"></a>IPv6基础</h2><h3 id="IPv6特点"><a href="#IPv6特点" class="headerlink" title="IPv6特点"></a>IPv6特点</h3><ul><li><p>128bits的地址方案，提供了巨大的IP地址空间</p></li><li><p>多等级层次有助于路由聚合，提高了因特网网络路由的效率及可扩展性</p><blockquote><p>IPv6可提供远大于IPv4的网络前缀，同一组织机构在其网络中可以只使用一个前缀，这样ISP可以把所有客户聚合形成一个前缀并发布出去。分层聚合使全局路由表项数量很少，转发效率更高。</p></blockquote></li><li><p>自动配置过程允许IPv6网络中的节点更加便捷的接入IPv6网络【实现了即插即用的联网方式】</p></li><li><p>重新编制机制使得IPv6提供商之间的转换对最终用户是透明的</p></li><li><p>不再有广播、不再有ARP，利用ICMPv6替代ARP</p></li><li><p>IPv6的包头比IPv4更加有效率，数据字段更少，去掉了包头校验和。</p></li></ul><h2 id="IPv地址表示"><a href="#IPv地址表示" class="headerlink" title="IPv地址表示"></a>IPv地址表示</h2><p>IPv6地址共128位，使用十六进制进行表示，分为8段，中间用”:”隔开。</p><p>如：2001:0000:3238:00E1:0063:0000:0000:FEFB</p><h3 id="IPv6地址简写"><a href="#IPv6地址简写" class="headerlink" title="IPv6地址简写"></a>IPv6地址简写</h3><p>以2001:0410:0000:0001:0000:0000:0000:45ff为例：</p><ul><li><p>每段的前导0可以省略，但至少保留1个0</p><blockquote><p>2001:410:0:1:0:0:0:45ff</p></blockquote></li><li><p>连续多个0可以缩写为”::”，但只能使用一次</p><blockquote><p>2001:410:0:1::45ff</p></blockquote></li></ul><h3 id="IPv6地址结构"><a href="#IPv6地址结构" class="headerlink" title="IPv6地址结构"></a>IPv6地址结构</h3><p>IPv6地址分为两部分：前缀及接口ID</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200829212643856.png" alt="image-20200829212643856"></p><p>接口标识生成方法：</p><ul><li><p>手工配置</p></li><li><p>系统通过软件自动生成</p></li><li><p>IEEE EUI-64规范自动生成</p><blockquote><p>将MAC地址转换为接口ID</p><p>MAC地址的独特性保证了接口ID的独特性</p><p>设备自动生成，不需认为干预</p></blockquote></li></ul><p>如下：将MAC地址为00-E0-4C-68-10-18，通过EUI-64自动生成IPv6的接口ID。</p><ul><li><p>步骤1：在MAC地址的高24位厂商ID和低24位厂商编号ID之间插入两个字节FFFE</p></li><li><p>步骤2：将U&#x2F;L位取反，此处0置为1</p><blockquote><p>U&#x2F;L 位是第一个字节的第七位，用于确定该地址是全球管理还是本地管理。如果为0就为全球管理，表示全球唯一地址；为1就为本地管理，表示本地唯一地址，是网络管理员为了加强自己对网络管理而指定的地址</p></blockquote></li></ul><p><img src= "/img/loading.gif" data-lazy-src="http://upimg.ruijie.com.cn/Editor/Image/20181227174445/2.png" alt="img"></p><h2 id="IPv6报头"><a href="#IPv6报头" class="headerlink" title="IPv6报头"></a>IPv6报头</h2><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200829111436585.png" alt="image-20200829111436585"></p><table><thead><tr><th>字段</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>version</td><td>4bit</td><td>6：表示IPv6</td></tr><tr><td>traffic class</td><td>8bit</td><td>流量类型，该字段及其功能类似于IPv4业务类型字段。该字段以区分业务编码点（DSCP）标记一个IPv6数据包，以此指明数据包应当如何处理。</td></tr><tr><td>flow label</td><td>20bit</td><td>流标签。该字段用来表示IP数据包的一个流，</td></tr><tr><td>payload length</td><td>16bit</td><td>该字段表示有效载荷的长度、有效载荷是指紧跟在IPv6基本报头的数据包，包含IPv6扩展报头</td></tr><tr><td>next header</td><td>8bit</td><td>下一报头，该字段指明了跟随在IPv6基本报头后的扩展报头的信息类型</td></tr><tr><td>Hop limit</td><td>8bit</td><td>跳数限制，该字段定义了IPv6数据包所能经过的最大跳数，这个字段和IPv4中的TTL字段非常相似。</td></tr><tr><td>Source address</td><td>128bit</td><td>该字段表示该报文的原地址</td></tr><tr><td>Destination address</td><td>128bit</td><td>该字段表示该报文的目的地址</td></tr><tr><td>extension headers</td><td>可变</td><td>扩展报头。IPv6取消了IPv4报头中的选项字段，并引入了多种扩展报文头，在提高处理效率的同时还增强了IPv6的灵活性，为IP协议提供了良好的扩展能力。当超过一种扩展报头被用在同一个分组里时，报头必须按照下列顺序出现：<br>- IPv6基本报头<br>- 逐跳选项扩展报头<br>- 目的选项扩展报头<br>- 路由扩展报头<br>- 分片扩展报头<br>- 授权扩展报头<br>- 封装安全有效载荷扩展报头<br>- 目的选项扩展报头(指那些将被分组报文的最终目的地处理的选项)<br>- 上层扩展报头<br>不是所有的扩展报头都需要被转发路由设备查看和处理的。路由设备转发时根据基本报头中Next Header值来决定是否要处理扩展头。<br>除了目的选项扩展报头出现两次（一次在路由扩展报头之前，另一次在上层扩展报头之前），其余扩展报头只出现一次。</td></tr></tbody></table><p>一个IPv6数据包可能包括0个或多个扩展包头，当使用多个扩展包头时，通过前面的包头的Next head字段指明该扩展包头后的扩展包头。有了扩展包头，中间路由器就不需要处理每一个可能出现的选项，提高了路由器处理数据包的速度，提高了其转发性能。在扩展报头链的最后就是有效负载。</p><p>扩展报头是可选的，只有需要该扩展报头对应的功能，发送主机才会添加相应扩展报头</p><p><img src= "/img/loading.gif" data-lazy-src="http://www.what21.com/sys/Data/Image/201809/1536653570431040156.jpg" alt="IPv6地址特点、优势及报文内容2.jpg"></p><p><strong>与IPv4报头相比，IPv6报头结构的提升：</strong> </p><ul><li>基本的IPv4报头长度为20个字节，基本的IPv6报头长度为40个字节；</li><li>由于2层与4层的校验已经足够健壮，取消了IP的三层校验；</li><li>取消中间节点的分片功能，分片重组功能由源端实现，通过Path MTU机制来发现路径MTU。即，源节点在正式发送数据之前，使用ICMPv6来检测路径上最小的MTU；</li><li>增加流标签，提高QoS效率。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IPv6基础&quot;&gt;&lt;a href=&quot;#IPv6基础&quot; class=&quot;headerlink&quot; title=&quot;IPv6基础&quot;&gt;&lt;/a&gt;IPv6基础&lt;/h2&gt;&lt;h3 id=&quot;IPv6特点&quot;&gt;&lt;a href=&quot;#IPv6特点&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下IP及DNS配置</title>
    <link href="http://tsung1992.github.io/Linux/Linux%E4%B8%8BIP%E5%8F%8ADNS%E9%85%8D%E7%BD%AE/"/>
    <id>http://tsung1992.github.io/Linux/Linux%E4%B8%8BIP%E5%8F%8ADNS%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux下配置IP"><a href="#linux下配置IP" class="headerlink" title="linux下配置IP"></a>linux下配置IP</h2><h3 id="1-相关文件"><a href="#1-相关文件" class="headerlink" title="1. 相关文件"></a>1. 相关文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /etc/network/</span></span><br><span class="line"><span class="comment"># vi interfaces</span></span><br><span class="line">(以下为文件内容)</span><br><span class="line"><span class="comment"># This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="comment"># and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 1.1.15.15</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">network 0.0.0.0</span><br><span class="line">gateway 1.1.15.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可用相关命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 x.x.x.x netmask x.x.x.x</span><br><span class="line">如：ifconfig eth0 1.1.1.1 netmask 255.255.0.0</span><br></pre></td></tr></table></figure><h3 id="2-配置虚拟IP地址"><a href="#2-配置虚拟IP地址" class="headerlink" title="2. 配置虚拟IP地址"></a>2. 配置虚拟IP地址</h3><p>相关命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth1:0  x.x.x.x netmask 255.255.0.0</span><br><span class="line">如：ifconfig eth0:0 2.1.1.1 netmask 255.255.0.0</span><br></pre></td></tr></table></figure><p>子网卡并不是实际上的网络接口设备，但可以作为网络接口在设备中出现。其必须依赖于物理网卡</p><h3 id="3-配置DNS"><a href="#3-配置DNS" class="headerlink" title="3. 配置DNS"></a>3. 配置DNS</h3><p>相关文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi  /etc/resolv.conf</span></span><br><span class="line">(以下为文件内容)</span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line"><span class="comment">#  search localdomain</span></span><br><span class="line"><span class="comment"># nameserver 192.168.23.2</span></span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>修改相应的nameserver内容即可。</p><p>若不通，则可继续修改如下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/nsswitch.conf</span></span><br><span class="line">(以下为相关内容)</span><br><span class="line"><span class="comment"># /etc/nsswitch.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example configuration of GNU Name Service Switch functionality.</span></span><br><span class="line"><span class="comment"># If you have the `glibc-doc-reference&#x27; and `info&#x27; packages installed, try:</span></span><br><span class="line"><span class="comment"># `info libc &quot;Name Service Switch&quot;&#x27; for information about this file.</span></span><br><span class="line"></span><br><span class="line">passwd:         compat</span><br><span class="line">group:          compat</span><br><span class="line">shadow:         compat</span><br><span class="line">gshadow:        files</span><br><span class="line"></span><br><span class="line"><span class="comment"># hosts:          files mdns4_minimal [NOTFOUND=return] dns myhostname</span></span><br><span class="line">hosts:          files dns wins</span><br><span class="line">networks:       files</span><br><span class="line"></span><br><span class="line">protocols:      db files</span><br><span class="line">services:       db files</span><br><span class="line">ethers:         db files</span><br><span class="line">rpc:            db files</span><br><span class="line"></span><br><span class="line">netgroup:       nis</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改相应的hosts部分，添加dns wins即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;linux下配置IP&quot;&gt;&lt;a href=&quot;#linux下配置IP&quot; class=&quot;headerlink&quot; title=&quot;linux下配置IP&quot;&gt;&lt;/a&gt;linux下配置IP&lt;/h2&gt;&lt;h3 id=&quot;1-相关文件&quot;&gt;&lt;a href=&quot;#1-相关文件&quot; class=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://tsung1992.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>tcpdump基础用法说明</title>
    <link href="http://tsung1992.github.io/Linux/tcpdump%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://tsung1992.github.io/Linux/tcpdump%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E8%AF%B4%E6%98%8E/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><hr><p>tcpdump是一个用于截取网络分组，并输出分组内容的工具。根据使用者的定义对网络上的数据包进行截获。</p><p>tcpdump针对网络网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句辅助去掉无用的信息。</p><p>其官网地址为：<a href="https://www.tcpdump.org/">tcpdump官网</a>，在官网中存在完整的<a href="https://www.tcpdump.org/manpages/tcpdump.1.html">英文说明文档</a></p><h2 id="2-常用tcpdump语法"><a href="#2-常用tcpdump语法" class="headerlink" title="2. 常用tcpdump语法"></a>2. 常用tcpdump语法</h2><hr><p>抓包选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-A 以ASCII格式打印出所有分组，并将链路层的头最小化</span><br><span class="line">-c 仅抓取指定数量的分组</span><br><span class="line">-i 指定监听的网络接口</span><br><span class="line">-n 对地址以数字方式显示，否则显示为主机名</span><br><span class="line">-nn 除了-n的作用外，还把端口显示为数值，否则显示端口服务器</span><br><span class="line">-P 指定要抓取的包是流入还是流出的包。可以给定的值为<span class="string">&quot;in&quot;</span>、<span class="string">&quot;out&quot;</span>、<span class="string">&quot;inout&quot;</span></span><br><span class="line">-XX 输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细</span><br><span class="line">-v 当分析和打印的时候，产生详细的输出</span><br><span class="line">-w 将抓包数据输出到文件中</span><br><span class="line">-r 从给定的数据包文件中读取数据</span><br></pre></td></tr></table></figure><h3 id="2-1-tcpdump表达式"><a href="#2-1-tcpdump表达式" class="headerlink" title="2.1 tcpdump表达式"></a>2.1 tcpdump表达式</h3><p>表达式用于筛选输出哪些类型的数据包，如果没有给定表达式，所有的数据包都将输出，否则输出表达式为true的包。在表达式中出现的shell元字符建议使用单引号包围。</p><p>一个基本的表达式单元格式为：tcpdump [options] [not] proto dir type</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. proto:通过给定协议限定匹配的数据包类型</span><br><span class="line">   常用的协议有：tcp/udp/arp/ip/ether/icmp等</span><br><span class="line">2. <span class="built_in">dir</span>：指定ID的方向</span><br><span class="line">   可以给定的值包括src/dst/src or dst/src and dst</span><br><span class="line">3. <span class="built_in">type</span>：指定ID的类型</span><br><span class="line">   可以给定的值有host/net/port/portrange</span><br></pre></td></tr></table></figure><h3 id="2-2-tcpdump示例"><a href="#2-2-tcpdump示例" class="headerlink" title="2.2 tcpdump示例"></a>2.2 tcpdump示例</h3><ol><li>监视指定网络接口的数据包</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -i eth1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>监视指定主机的数据包</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump host 1.1.1.1</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 src host 1.1.1.1</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 dst host 1.1.1.1</span></span><br></pre></td></tr></table></figure><p>抓取主机为1.1.1.1的网络数据<br>指定源地址，1.1.1.1<br>指定目的地址，1.1.1.1<br>3. 监视指定端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -i eth1 port 25</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 src port 25</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 dst port 25</span></span><br></pre></td></tr></table></figure><ol start="4"><li>网络过滤</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -i eth1 net 1.1</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 src net 1.1</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 dst net 1.1</span></span><br></pre></td></tr></table></figure><ol start="5"><li>监视指定协议</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcpdump -i eth1 arp</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 ip</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 tcp</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 udp</span></span><br><span class="line"><span class="comment"># tcpdump -i eth1 icmp</span></span><br></pre></td></tr></table></figure><ol start="6"><li>示例语句</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">抓取经过eth1接口，目的地址为1.1.1.1或1.1.1.2端口是80的tcp数据</span><br><span class="line"><span class="comment"># tcpdump -i eth1 &#x27;((tcp) and (port 80) and ((dst host 1.1.1.1) or (dst host 1.1.1.2)))&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;tcpdump是一个用于截取网络分组，并输出分组内容的工具。根据使用者的定义对网络上的数据包进行截获。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://tsung1992.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>地址解析协议</title>
    <link href="http://tsung1992.github.io/network/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
    <id>http://tsung1992.github.io/network/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.779Z</updated>
    
    <content type="html"><![CDATA[<p>地址解析协议(ARP)提供了一种IPv4地址和各种网络技术使用的硬件地址之间的映射。</p><p>ARP仅用于IPv4、IPv6使用邻居发现协议，被合并入ICMPv6</p><h2 id="直接交付"><a href="#直接交付" class="headerlink" title="直接交付"></a>直接交付</h2><p>ARP运行要求：仅适用于广播网络，链路层能将一个消息交付到它连接的所有网络设备。</p><p>在一个共享的链路层网段上，ARP向所有主机发送一个称为ARP请求的以太网帧。</p><p>以太网主机在同一广播域中，ARP查询使用链路层广播帧发送，并被所有主机接收。</p><p>IP地址匹配的主机直接向请求主机返回响应。IP地址不匹配的主机主动丢弃ARP查询</p><h2 id="ARP缓存表"><a href="#ARP缓存表" class="headerlink" title="ARP缓存表"></a>ARP缓存表</h2><p>ARP高效运行的关键是维护每个主机结合路由器上的ARP缓存表。</p><p>该缓存使用地址解析为每个接口维护从网络层地址到硬件地址的最新应用。</p><p>当IPv4地址映射到硬件地址时，它对应于高速缓存中的一个条目，其正常到期时间是条目创建开始后的20分钟。</p><p>查看ARP缓存表：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arp -a</span><br><span class="line"></span><br><span class="line">接口: 192.168.31.33 --- 0xe</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.31.1          28-6c-07-0a-11-3a     动态        </span><br><span class="line">  192.168.31.157        88-bf-e4-99-fa-b0     动态        </span><br><span class="line">  192.168.31.255        ff-ff-ff-ff-ff-ff     静态        </span><br><span class="line">  224.0.0.2             01-00-5e-00-00-02     静态        </span><br><span class="line">  224.0.0.22            01-00-5e-00-00-16     静态        </span><br></pre></td></tr></table></figure><h3 id="动态ARP"><a href="#动态ARP" class="headerlink" title="动态ARP"></a>动态ARP</h3><p>动态ARP指的是通过报文去学习ARP表项，不需要管理员手工建立和维护，动态条目随时间推移自动添加和删除</p><blockquote><ul><li>每个动态ARP缓存条目默认的生命周期是两分钟。当超过两分钟，该条目会被删掉。所以，生命周期也被称为超时值。</li><li>延长规则：当ARP条目已存在，使用该条目后，将会重设超时值为两分钟。</li></ul></blockquote><h3 id="静态ARP"><a href="#静态ARP" class="headerlink" title="静态ARP"></a>静态ARP</h3><p>静态ARP指的是需要管理员手工指定建立AP-MAC映射表，需要管理员手工建立和维护。</p><h2 id="ARP帧格式"><a href="#ARP帧格式" class="headerlink" title="ARP帧格式"></a>ARP帧格式</h2><p><img src= "/img/loading.gif" data-lazy-src="/images/2012041215590890.jpg" alt="2012041215590890"></p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200719180849457.png" alt="image-20200719180849457"></p><ul><li>硬件类型：表示硬件地址的类型，值为1表示以太网地址</li><li>协议类型：表示要映射的协议地址类型，值为0x0800表示IP地址类型</li><li>硬件地址长度和协议地址长度：分别指出硬件地址和协议的长度，以字节为单位。对于以太网上 IP 地址的ARP请求或应答来说，它们的值分别为 6 和 4</li><li>操作类型(op)：1表示ARP请求，2表示ARP应答，RARP 请求为 3，RARP 响应为 4</li></ul><h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>免费ARP：发生在一台主机发送ARP请求以寻找自己的地址</p><p>应用：</p><ul><li>用于检测IP地址冲突，当一台主机发送了免费ARP请求报文后，如果收到了ARP响应报文，则说明网络内衣存在使用该IP的主机</li><li>利用免费ARP确认设备接口IP地址</li><li>使用免费ARP报文，更新某些设备的ARP表现</li><li>利用免费ARP的攻击</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地址解析协议(ARP)提供了一种IPv4地址和各种网络技术使用的硬件地址之间的映射。&lt;/p&gt;
&lt;p&gt;ARP仅用于IPv4、IPv6使用邻居发现协议，被合并入ICMPv6&lt;/p&gt;
&lt;h2 id=&quot;直接交付&quot;&gt;&lt;a href=&quot;#直接交付&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>物理层及数据链路层</title>
    <link href="http://tsung1992.github.io/network/%E7%89%A9%E7%90%86%E5%B1%82&amp;%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://tsung1992.github.io/network/%E7%89%A9%E7%90%86%E5%B1%82&amp;%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层的功能不需要地址</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200716225644709.png" alt="image-20200716225644709"></p><p>Frame 13： 74 bytes on wire (592 bits),74 bytes captured (592 bits)</p><p>13号帧，线路74字节，实际捕获74字节</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Encapsulation type： Ethernet(1)  # 封装类型</span><br><span class="line">Arrival Time: # 捕获日期和时间</span><br><span class="line">Epoch Time：# 时间戳，另一种时间表示方式</span><br><span class="line">[Time delta from previous captured frame: ]   #此包与前一包的时间间隔</span><br><span class="line">[Time since reference or first frame: ]       #此包与第一帧的时间间隔</span><br><span class="line">Frame Number: # 帧序号</span><br><span class="line">Frame Length: # 帧长度</span><br><span class="line">Capture Length： # 捕获长度 （通常情况下帧长度和捕获长度是相同的）</span><br><span class="line">Protocols in frame：帧内封装的协议层次结构</span><br></pre></td></tr></table></figure><p>EtherType 是以太帧里的一个字段，用来指明应用于帧数据字段的协议</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>主要目的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 为IP模块发送和接收IP数据报</span><br><span class="line">2. 为ARP模块发送ARP请求和接收ARP应答</span><br><span class="line">3. 为RARP发送RARP请求和接收RARP应答</span><br></pre></td></tr></table></figure><h3 id="以太网和IEEE-802-封装"><a href="#以太网和IEEE-802-封装" class="headerlink" title="以太网和IEEE 802 封装"></a>以太网和IEEE 802 封装</h3><p>以太网是当今TCP&#x2F;IP采用的主要的局域网技术，它采用一种称作<strong>CSMA&#x2F;CD的媒体接入方法</strong>，其意思是带冲突检测的载波侦听多路接入。它的速率是10Mb&#x2F;s，地址为48bit。</p><p><img src= "/img/loading.gif" data-lazy-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1595062714663&di=bce2d089aeac55bb6145289deea316aa&imgtype=0&src=http://jc.feikuaixue.com/wp-content/uploads/2015/10/frame.png" alt="img"></p><p>前导码(8B)：在帧的前面插入8B，使接收端和发送端进行时钟同步，其中7B为前同步码，1B为帧开始定界符。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前同步码均为：10101010</span><br><span class="line">帧开始定界符为：10101011，最后一个字节为告诉接收端“重要的帧开始了”</span><br></pre></td></tr></table></figure><p>目的MAC(6B)：包含目的主机网卡MAC地址或广播地址</p><p>源MAC(6B)：发送端的网卡MAC地址</p><p>类型(2B)：之处接收端收到该帧时，将该帧的载荷数据交付给谁处理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x0800:IPv4</span><br></pre></td></tr></table></figure><p>802.1Q标签：</p><p>CRC(4B)：为了让接收端对接收到的帧进行差错检验(也做帧校验序列，FCS)</p><blockquote><p> FCS: 该字段有 4 个字节，表示帧校验序列，用于校验帧是否出错。该字段内容已被网络设备滤去，抓包软件已无法获取。</p></blockquote><p>帧间距：表示两个Frame之间间隔大小，设备发送完一个Frame后，并不会立刻发送下一个，而是等待IFG的间隔才会继续发送。</p><blockquote><p>最小的帧间隙为12bytes，主要为了避免冲突(参考以太网的CSMA&#x2F;CD特定)</p></blockquote><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718222220022.png" alt="image-20200718222220022"></p><p><strong>为什么wireshark抓不到帧尾的FCS 4字节和以太网V2的前序8字节</strong>？</p><p>因为wireshark把这2个都给过滤了。</p><p>在物理层上网卡要先去掉前导同步码和帧开始定界符，然后对帧进行CRC检验，如果帧校验和错，就丢弃此帧。如果校验和正确，就判断帧的目的硬件地址是否符合自己的接收条件（目的地址是自己的物理硬件地址、广播地址、可接收的多播硬件地址等），如果符合，就将帧交“设备驱动程序”做进一步处理。这时我们的抓包软件才能抓到数据，因此，抓包软件抓到的是去掉前导同步码、帧开始分界符、FCS之外的数据</p><p>通过OmniPeek抓包查看FCS内容：<br><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718224849805.png" alt="image-20200718224849805"></p><h3 id="环回"><a href="#环回" class="headerlink" title="环回"></a>环回</h3><p>概念：使用Internet协议与同一计算机上的服务器通信。为实现这个目标，大多数实现支持一种工作在网络层的环回能力，通常使用一个虚拟的环回网络接口来实现。</p><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>MTU：最大传输单元，MTU是数据链路层的概念，MTU限制的是数据链路层的payload，即上层协议的大小，如IP，ICMP等。</p><p><strong>（涉及到的内容分片和重组）</strong></p><table><thead><tr><th align="left">OSI中的层</th><th align="left">功能</th><th align="left">TCP&#x2F;IP协议族</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="left">文件传输，电子邮件，文件服务，虚拟终端</td><td align="left">TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td></tr><tr><td align="left">表示层</td><td align="left">数据格式化，代码转换，数据加密</td><td align="left">没有协议</td></tr><tr><td align="left">会话层</td><td align="left">解除或建立与别的接点的联系</td><td align="left">没有协议</td></tr><tr><td align="left">传输层</td><td align="left">提供端对端的接口</td><td align="left">TCP，UDP</td></tr><tr><td align="left">网络层</td><td align="left">为数据包选择路由</td><td align="left">IP，ICMP，RIP，OSPF，BGP，IGMP</td></tr><tr><td align="left">数据链路层</td><td align="left">传输有地址的帧以及错误检测功能</td><td align="left">SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr><tr><td align="left">物理层</td><td align="left">以二进制数据形式在物理媒体上传输数据</td><td align="left">ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><h4 id="为什么是1500"><a href="#为什么是1500" class="headerlink" title="为什么是1500?"></a>为什么是1500?</h4><blockquote><p>标准的以太网数据帧大小是：<code>1518</code>，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 &#x3D; 1500</p></blockquote><h4 id="抓包-1"><a href="#抓包-1" class="headerlink" title="抓包"></a>抓包</h4><ol><li><p>ping 2.2.2.2</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718232244004.png" alt="image-20200718232244004"></p></li><li><p>ping 2.2.2.2 -l 1</p><p>数据大小设置为1，此时抓包可见Padding内容，使得payload达到最小要求(MTU–&gt; 46，若加上头部信息，为64)</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718232325692.png" alt="image-20200718232325692"></p></li><li><p>ping 2.2.2.2 -l 2000</p><p>出现了分片，分为1514及562两个报文</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718232934289.png" alt="image-20200718232934289"></p></li></ol><p>1514 &#x3D; 6+6+2+20(IPv4头部)+1480(payload)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h2&gt;&lt;p&gt;物理层的功能不需要地址&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;/im</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
    <category term="网络基础" scheme="http://tsung1992.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    <category term="TCP-IPv4" scheme="http://tsung1992.github.io/tags/TCP-IPv4/"/>
    
  </entry>
  
  <entry>
    <title>网络连接设备</title>
    <link href="http://tsung1992.github.io/network/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87/"/>
    <id>http://tsung1992.github.io/network/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转发器-集线器"><a href="#转发器-集线器" class="headerlink" title="转发器&#x2F;集线器"></a>转发器&#x2F;集线器</h2><p>仅发生在物理层，完成比特数据在物理层的传输</p><p>作用：实现物理层的连接，对衰减的信号进行放大整形或再生，起到扩展网段距离的作用。</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200719115642773.png" alt="image-20200719115642773"></p><h2 id="网桥-交换机"><a href="#网桥-交换机" class="headerlink" title="网桥&#x2F;交换机"></a>网桥&#x2F;交换机</h2><p>交换机作用于数据链路层和物理层</p><p>交换机是一种用于电信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。</p><ul><li><p>A–D之间的数据交换没有进过网桥，这是因为两者连接在网桥的同一个端点处。</p></li><li><p>A–G之间的数据交换进过网桥，这是因为两者连接在网桥不同的端点处</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200719120121170.png" alt="image-20200719120121170"></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是用来延伸、拓展网络的设备。</p><p>一个接口连接是一个网络，在局域网内部通常使用集线器或交换机扩展网络</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200719143542291.png" alt="image-20200719143542291"></p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><p>网关是一种充当转换重任的计算机系统或设备。在使用不同的通信协议、数据格式或语言,甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同时，网关也可以提供过滤和安全功能。大多数网关运行在OSI 7层协议的顶层–应用层</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200719151338198.png" alt="image-20200719151338198"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;转发器-集线器&quot;&gt;&lt;a href=&quot;#转发器-集线器&quot; class=&quot;headerlink&quot; title=&quot;转发器&amp;#x2F;集线器&quot;&gt;&lt;/a&gt;转发器&amp;#x2F;集线器&lt;/h2&gt;&lt;p&gt;仅发生在物理层，完成比特数据在物理层的传输&lt;/p&gt;
&lt;p&gt;作用：实现物理层的连接</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP-IP详解概述</title>
    <link href="http://tsung1992.github.io/network/%E6%A6%82%E8%BF%B0/"/>
    <id>http://tsung1992.github.io/network/%E6%A6%82%E8%BF%B0/</id>
    <published>2020-08-25T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><ul><li><p>ISO标准(ISO组织制定)</p><p>​    开放系统互连(open system interconnection)，将不同系统进行互连所构建的模型</p><p>​    参考模型：不是实际的协议，并不是在实际过程汇总进行实用的模型，而是作为参考、知道的模型</p></li><li><p>目的</p><p>​    使两个不同的系统能够通信，而不需要改变底层的硬件或软件逻辑</p><p>​    不同的系统：一台计算机、一部电话</p></li></ul><p><strong>OSI不是协议，是网络体系结构的概念模型</strong></p><h2 id="层次体系结构"><a href="#层次体系结构" class="headerlink" title="层次体系结构"></a>层次体系结构</h2><p>网络支持层：为通信提供传输的支持</p><p>应用支持层：通常由软件实现的，应用软件，为网络应用提供相应的支持</p><p>传输层：将上下两层结合在一起</p><p><img src= "/img/loading.gif" data-lazy-src="https://pic1.zhimg.com/80/v2-d15cc181093cdfaaafde8d7e712ede45_720w.png" alt="img"></p><h2 id="对等层通信"><a href="#对等层通信" class="headerlink" title="对等层通信"></a>对等层通信</h2><p>层次模型在通信过程中是如何使用的。</p><p>A 和 B 通过中间节点进行通信(网络互连设备)</p><p>两个系统之间如何实现通信，其通信方式称为对等层通信。</p><p>对等层概念可通过层次模型进行对应。</p><p>下层：服务提供者</p><p>上层：服务使用者</p><p>接口：层与层之间存在一个接口，为了实现层与层之间服务的提供与使用的通道</p><p>对等层：不同主机之间的相同层次被称为对等层(Peer)。主机A的应用层和主机B的应用层互为对等层、主机A的会话层和主机B的会话层互为对等层</p><p>对等进程&#x2F;对等实体</p><p>对等层协议：对等实体之间交换数据或通信时必须遵守的规则</p><p>对等层与对等实体：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每一层可以同时存在多个实体</span></span><br><span class="line">存在通信关系的对等层实体才是对等实体</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每一层可以同时存在多个协议</span></span><br><span class="line">协议是对等实体间的通信规则</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200717233916992.png" alt="image-20200717233916992"></p><h2 id="数据通信-封装"><a href="#数据通信-封装" class="headerlink" title="数据通信-封装"></a>数据通信-封装</h2><p>7层模型，最上一层直接面向用户，最下一层直接面向物理介质。真正的数据传输方向是发送方是由高层送往底层，接收方由底层依次送往高层</p><p>PDU：协议数据单元，对等实体之间通信时所传输的信息内容，每一层封装成的PDU均有自己的名字</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">应用层、表示层和会话层封装成的PDU被统一称为Data(数据)</span><br><span class="line">传输层的被称为数据段(segement)</span><br><span class="line">在网络层的被称为packet(IP数据包，分组)</span><br><span class="line">数据链路层(frame)帧</span><br><span class="line">物理层的被称为bit流</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718101937721.png" alt="image-20200718101937721"></p><p>在OSI参考模型看来，数据通信时，是一层一层处理，逐层封装好，在物理上进行实在的传输：从源主机（SOURCE）的应用层发出来的数据是有一定格式的协议数据单元，称为PDU（protocol data unit）。应用层发给下一层表示层后，在PDU前面加上了本层控制信息，也就是图中的AH，加在头部。加了头部PH的A-PDU，更新为本层的PDU，也就是要发给第五层会话层的内容。即A-PDU+PH&#x3D;P-PDU。上一层向下一层发送PDU，逐层加上本层的头部后成为下一层的PDU。直至发到数据链路层，数据链路层还加一个尾部，也就是DT，起到校验作用，如果数据正确，继续传输，数据错误直接丢掉不继续传输。数据链路层发给物理层后，物理层将PDU转换为二进制编码（比特流），通过硬件转换为信号发送出去。这样源主机七层任务完成。</p><p>图右侧是目的主机的数据接收过程：接收到硬件的二进制信号后，物理层转换为PDU发个数据链路层。数据链路层拆掉头部和尾部后，将赤裸的PDU送给网络层。网络层再拆掉头部，送入下一层，逐层拆掉头部，到了送给应用层时，前面不同层添加的头部完全被拆干净，留下原本发送的最原始PDU，也就是用户数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20181004204141181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d3d19oZWxsb3dvcmxkX2NvbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718220002327.png" alt="image-20200718220002327"></p><p>在构造协议数据单元时会在头部增加控制信息，这些控制信息包括：</p><ol><li><p>地址：用来标识发送端和接收端，源主机得知道数据往哪发，目的主机得知道数据是发给谁的</p></li><li><p>差错检测编码：用于差错检测或纠正</p></li></ol><p>3）协议控制：实现协议功能的附加信息(优先级、服务质量及安全控制等)</p><h2 id="层次功能"><a href="#层次功能" class="headerlink" title="层次功能"></a>层次功能</h2><table><thead><tr><th>层次</th><th>功能</th><th>网络协议</th></tr></thead><tbody><tr><td>应用层</td><td>提供应用协议，用户与网络面对面菜刀接口</td><td>HTTP、TFTP、FTP、SMTP</td></tr><tr><td>表示层</td><td>数据的编码、翻译、压缩、解压缩、加密、解密、将数据翻译为相对应的编码格式，然后展现到应用程序中</td><td>telnet、Rlogin、SNMP、Gopher</td></tr><tr><td>会话层</td><td>主要用来管理会话(建立连接、保持连接、断开连接)</td><td>SMTP、DNS</td></tr><tr><td>传输层</td><td>提供端到端的连接方式(可靠的传输方式、不可靠的传输方式、数据包重组)</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>负责设备的IP地址寻址，寻找网络中目的位置，并在去往目的的多条路径中选择一条最佳的路径</td><td>IP、ICMP、ARP、RARP、AKP、UUCP</td></tr><tr><td>数据链路层</td><td>协商、流量控制、差错控制、物理寻址</td><td>FDDI、Ethernet、Arpanet、PDN、PPP</td></tr><tr><td>物理层</td><td>定义了网络通信接口及介质的标准，以及将上层封装的数据转换为bit的二进制方式进行传输</td><td>IEEE802.1A，IEEE 802.2到IEEE 802.11</td></tr></tbody></table><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190105165116628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNjIy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="TCP-IP分层"><a href="#TCP-IP分层" class="headerlink" title="TCP&#x2F;IP分层"></a>TCP&#x2F;IP分层</h2><p>TCP&#x2F;IP通常被认为是一个四层协议系统，每一层负责不同的功能。</p><p><strong>链路层</strong>：数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。一起处理与电缆(或其他任何传输媒介)的物理接口细节。</p><p><strong>网络层</strong>：处理分组在网络中的活动，如分组的选路。网络层协议包括IP协议(网际协议)、ICMP协议(Internet互联网控制报文协议)，以及IGMP协议(Internet组管理协议)</p><p><strong>运输层</strong>：主要为两台主机上的应用程序提供端到端的通信。</p><p>​TCP(传输控制协议)：为两台主机提供高可靠性的数据通信，它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确定接收到的分组，设置发送最后确认分组的超时时钟等。</p><p>​UDP(用户数据报协议)：为应用层提供一种非常简单的服务，不可靠的数据通信。</p><p><strong>应用层</strong>：负责处理特定的应用程序细节</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet:远程登录</span><br><span class="line">FTP：文件传输协议</span><br><span class="line">SMTP：简单邮件传送协议</span><br><span class="line">SNMP：简单网络管理协议</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200716213159430.png" alt="image-20200716213159430"></p><p>TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议。</p><p>TCP虽然使用不可靠的IP服务，但却提供一种可靠的运输层服务</p><p>UDP为应用程序发送和接收数据报，一个数据包是指从发送方传输到接收方的一个信息单元。UDP是不可靠的，不能保证数据报能安全无误的达到最终目的</p><p>IP是网络层上的主要协议，同时被TCP和UDP使用</p><p>ICMP是IP协议的附属协议，IP层用它来与其它主机或路由器交换报错报文和其它重要信息。</p><p>IGMP是Internet组管理协议，它用来把一个UDP数据报多播到多个主机。</p><p>ARP(地址解析协议)和RARP(逆地址解析协议)是某些网络接口使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层知道被当做一串比特流送入网络。</p><p>TCP传给IP的数据单元称作TCP报文段或简称为TCP端</p><p>IP传给网络接口层的数据单元称作IP数据报</p><p>通过以太网传输的比特流称作帧</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200716215110195.png" alt="image-20200716215110195"></p><p>以太网数据帧的物理特性是其长度必须在46~1500字节之间</p><h2 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h2><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><ul><li>用来标识通信的节点(物理网内部)</li><li>节点由所属的LAN或WAN指定</li><li>在局域网或广域网内是唯一的</li><li>也称为链路地址&#x2F;硬件地址</li><li>并不是用于物理层，而是用于数据链路层(物理层主要完成比特流的传送，仅涉及到信号转换，不涉及寻址)</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>标识通信节点的网络连接(逻辑网络内)</li><li>该地址有Internet指定，在Internet内唯一</li><li>32bit，点分十进制进行标识</li></ul><h3 id="端口地址"><a href="#端口地址" class="headerlink" title="端口地址"></a>端口地址</h3><ul><li>标识于通信进程</li><li>由操作系统来指定，在一台计算机内是唯一的</li><li>作用于传输层，用于标识应用层的信息</li></ul><h3 id="TCP-IP中的地址与层次"><a href="#TCP-IP中的地址与层次" class="headerlink" title="TCP&#x2F;IP中的地址与层次"></a>TCP&#x2F;IP中的地址与层次</h3><p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/757858/201510/757858-20151001155100871-838532433.jpg" alt="img"></p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718112652511.png" alt="image-20200718112652511"></p><p>更新图标</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200718103144528.png" alt="image-20200718103144528"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OSI参考模型&quot;&gt;&lt;a href=&quot;#OSI参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI参考模型&quot;&gt;&lt;/a&gt;OSI参考模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ISO标准(ISO组织制定)&lt;/p&gt;
&lt;p&gt;​    开放系统互连(open sy</summary>
      
    
    
    
    <category term="TCP-IP详解" scheme="http://tsung1992.github.io/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>docker 镜像基本操作</title>
    <link href="http://tsung1992.github.io/docker/docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://tsung1992.github.io/docker/docker%E9%95%9C%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.632Z</updated>
    
    <content type="html"><![CDATA[<p>镜像是Docker的三大核心概念中最为重要的。Docker运行容器前需要本地存在对应的镜像，若没有镜像存在与本地，会先从仓库从获取下载。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>docker官方提供数十万个镜像供大家下载，包括且不限于常用的ubuntu、apache、nginx、mysql、mongodb等常用的服务器及数据库等。</p><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200816204834869.png" alt="image-20200816204834869"></p><p>可使用docker pull命令从镜像源下载镜像。</p><p><strong>docker pull</strong>：获取镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line"></span><br><span class="line">root@ubuntu:~#  docker pull ubuntu</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">3ff22d22a855: Pull complete </span><br><span class="line">e7cb79d19722: Pull complete </span><br><span class="line">323d0d660b6a: Pull complete </span><br><span class="line">b7f616834fd0: Pull complete </span><br><span class="line">Digest: sha256:5d1d5407f353843ecf8b16524bc5565aa332e9e6a1297c73a92d3e754b8a636d</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">docker.io/library/ubuntu:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过下载过程，可以看到，一个镜像一般是由多个层（layer） 组成，类似 f7e2b70d04ae这样的串表示层的唯一 ID。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PS: 实际上完整的 ID 包括了 256 个 bit, 64 个十六进制字符组成的。</span></span><br></pre></td></tr></table></figure><p><strong>docker images</strong>  查看所有本地的主机上的镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images  #列出本地的镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY镜像的仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID    镜像的id</span><br><span class="line">CREATED     创建的时间</span><br><span class="line">SIZE        镜像的大小</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">-a--all    显示所有镜像，包括中间层</span><br><span class="line">-q  --quiet  仅显示镜像ID</span><br></pre></td></tr></table></figure><p><strong>docker search</strong>  搜索镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relati...   9520      [OK]       </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of M...   3456      [OK]       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">    --filter=STARS=3000 搜索starts&gt;3000的镜像</span><br><span class="line">root@a5-vm04:~# docker search mysql --filter=STARS=5000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relati...   9520      [OK]   </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>docker rmi</strong> 删除镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi ID 删除指定的镜像</span><br><span class="line">docker rmi -f $(docker images -aq)  删除全部的镜像</span><br></pre></td></tr></table></figure><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><p><strong>使用inspect命令查看镜像详细信息</strong></p><p>通过<code>docker inspect</code>命令，可以获取镜像的详细信息，其中包括创建者、各层的数字摘要等。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker inspect ubuntu</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:1e4467b07108685c38297025797890f0492c4ec509212e2e4b4822d367fe6bc8&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;ubuntu:latest&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [</span><br><span class="line">            &quot;ubuntu@sha256:5d1d5407f353843ecf8b16524bc5565aa332e9e6a1297c73a92d3e754b8a636d&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2020-07-24T14:38:35.464294608Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;9d62e8d762827123636cb28eacfed9975890fd659cac66adee63fc3a969bb8a9&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;9d62e8d76282&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;#(nop) &quot;,</span><br><span class="line">                &quot;CMD [\&quot;/bin/bash\&quot;]&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br><span class="line">            &quot;Image&quot;: &quot;sha256:905a090e9b85447aff61cda51518fc1ab45af28e185981b70bc73dc9c03abf13&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;DockerVersion&quot;: &quot;18.09.7&quot;,</span><br><span class="line">        &quot;Author&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/bash&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ArgsEscaped&quot;: true,</span><br><span class="line">            &quot;Image&quot;: &quot;sha256:905a090e9b85447aff61cda51518fc1ab45af28e185981b70bc73dc9c03abf13&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: null</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;Os&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;Size&quot;: 73859057,</span><br><span class="line">        &quot;VirtualSize&quot;: 73859057,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/0d948d7943f1db41d38707ae39e87bcf6dc842dbeb77c3b3ba332e366d38c02e/diff:/var/lib/docker/overlay2/b2160599c8339e155b44534f956ae2d1dab00cdf9e8cbbb1f013d5581f0771b8/diff:/var/lib/docker/overlay2/e64630287d462a45307b48add39bd3959d3c7e7c6b3404dd4c41e241d5d90b65/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/d4e7ee51914e5a7b57f24cdff4882a9810c628d4fa3db1f806c2c5b259188085/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/d4e7ee51914e5a7b57f24cdff4882a9810c628d4fa3db1f806c2c5b259188085/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/d4e7ee51914e5a7b57f24cdff4882a9810c628d4fa3db1f806c2c5b259188085/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:ce30112909569cead47eac188789d0cf95924b166405aa4b71fb500d6e4ae08d&quot;,</span><br><span class="line">                &quot;sha256:8eeb4a14bcb4379021c215017c94800a848a8203a8ce76aa1bd211d4c995f792&quot;,</span><br><span class="line">                &quot;sha256:a37e74863e723df4ddd599ef1b7d9a68e2301794a8c37c2370f8c2c8993ef72c&quot;,</span><br><span class="line">                &quot;sha256:095624243293a7dfdb582f8471d6e2d9d7772dd621bc57906b034c59f388ebac&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Metadata&quot;: &#123;</span><br><span class="line">            &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用history命令查看镜像历史</strong></p><p>通过<code>docker history</code>命令，可以列出各个层(layer)的创建信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker history ubuntu</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">1e4467b07108        3 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           3 weeks ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &#x27;do…   7B                  </span><br><span class="line">&lt;missing&gt;           3 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &#x27;#!/bin/sh&#x27; &gt; /…   811B                </span><br><span class="line">&lt;missing&gt;           3 weeks ago         /bin/sh -c [ -z &quot;$(apt-get indextargets)&quot; ]     1.01MB              </span><br><span class="line">&lt;missing&gt;           3 weeks ago         /bin/sh -c #(nop) ADD file:65a1cc50a9867c153…   72.9MB              </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;镜像是Docker的三大核心概念中最为重要的。Docker运行容器前需要本地存在对应的镜像，若没有镜像存在与本地，会先从仓库从获取下载。&lt;/p&gt;
&lt;h2 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="docker" scheme="http://tsung1992.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="http://tsung1992.github.io/tags/docker/"/>
    
    <category term="容器" scheme="http://tsung1992.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Content-type属性</title>
    <link href="http://tsung1992.github.io/http/Content-Type/"/>
    <id>http://tsung1992.github.io/http/Content-Type/</id>
    <published>2020-08-16T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是content-type"><a href="#什么是content-type" class="headerlink" title="什么是content-type"></a>什么是content-type</h2><p>Content-type首部字段说明了实体主体的MIME类型。</p><p>content-type(MediaType)，即Internet Media Type，互联网媒体类型，也称为MIME类型。在互联网中有成百上千中不同的数据类型，HTTP在传输数据对象时会为他们打上称为MIME的数据格式标签，用于区分数据类型。</p><p>Content-Type是HTTP的实体首部字段，用来表示请求或响应中的媒体类型。它用来告诉服务端如何处理请求的数据，以及告诉客户端（一般是浏览器）如何解析响应的数据，比如显示图片，解析并展示html等等</p><h2 id="Conten-type格式"><a href="#Conten-type格式" class="headerlink" title="Conten-type格式"></a>Conten-type格式</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Content-type：type/subtype；parameter</span><br><span class="line"> - type：主类型，任意的字符串，人text，如果是*号代表所有</span><br><span class="line"> - subtype：子类型，任意的字符串，如html，如果是*号代表所有，用“/”与主类型隔开</span><br><span class="line"> - parameter：可选参数，如charset，boundary等</span><br></pre></td></tr></table></figure><p>例如：</p><p>Content-type: text&#x2F;html</p><p>Content-type: application&#x2F;json; charset:utf-8</p><h2 id="常见的Content-type类型"><a href="#常见的Content-type类型" class="headerlink" title="常见的Content-type类型"></a>常见的Content-type类型</h2><h3 id="以text开头的媒体格式类型"><a href="#以text开头的媒体格式类型" class="headerlink" title="以text开头的媒体格式类型"></a>以text开头的媒体格式类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">text/html:HTML格式</span><br><span class="line">text/plain：纯文本格式</span><br><span class="line">test/xml：XML格式  (什么是XML？指可扩展标记语言（eXtensible Markup Language），被设计用来传输和存储数据</span><br></pre></td></tr></table></figure><h3 id="以image开头的媒体格式类型"><a href="#以image开头的媒体格式类型" class="headerlink" title="以image开头的媒体格式类型"></a>以image开头的媒体格式类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">image/gif：gif图片格式</span><br><span class="line">image/jpeg：jpg图片格式</span><br><span class="line">image/png：png图片类型</span><br></pre></td></tr></table></figure><h3 id="以application开头的媒体格式类型"><a href="#以application开头的媒体格式类型" class="headerlink" title="以application开头的媒体格式类型"></a>以application开头的媒体格式类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">application/xhtml+xml: XHTML格式</span><br><span class="line">application/xml：XML数据格式</span><br><span class="line">application/atom+xml：Atom XML聚合格式</span><br><span class="line">application/json：JSON数据格式</span><br><span class="line">application/pdf：pdf格式</span><br><span class="line">application/octet-stream：二进制流数据(如常见的文件下载)</span><br><span class="line">application/x-www-form-urlencoded：&lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。</span><br><span class="line"></span><br><span class="line">另外还有一种常见的媒体格式是上传文件之时使用的：</span><br><span class="line">multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式。</span><br></pre></td></tr></table></figure><h2 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h2><h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h3><p>(1) 浏览器的原生form表单</p><p>(2) 提交的数据按照key1&#x3D;val1&amp;key2&#x3D;val2的方式进行编码，key和val都进行URL转码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/login.php HTTP1.1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: http://10.160.15.105</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"></span><br><span class="line">Login=Login&amp;password=admin&amp;username=admin</span><br></pre></td></tr></table></figure><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h3><p>常见的post数据提交的方式，使用表单上传文件时，必须让form的enctype等于该值。</p><h4 id="enctype属性"><a href="#enctype属性" class="headerlink" title="enctype属性:"></a>enctype属性:</h4><p>enctype：规定了form表单在发送到服务器时候编码方式，它有如下的三个值。</p><ol><li>application&#x2F;x-www-form-urlencoded：默认的编码方式。但是在用文本的传输和MP3等大型文件的时候，使用这种编码就显得效率低下。</li><li>multipart&#x2F;form-data：指定传输数据为二进制类型，比如图片、mp3、文件。</li><li>text&#x2F;plain：纯文体的传输。空格转换为 “+” 加号，但不对特殊字符编码。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;form enctype=&quot;multipart/form-data&quot; action=&quot;#&quot; method=&quot;POST&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;MAX_FILE_SIZE&quot; value=&quot;100000&quot; /&gt;</span><br><span class="line">Choose an image to upload:</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;input name=&quot;uploaded&quot; type=&quot;file&quot; /&gt;&lt;br /&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; name=&quot;Upload&quot; value=&quot;Upload&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>请求头示例：（以下为上传xml文件）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/upload/ HTTP/1.1</span><br><span class="line">Host: 1.1.1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 1311</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Origin: http://1.1.1.1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">DNT: 1</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryhrzKECyteqHqat1e</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Referer: http://1.1.1.1/dvwa/vulnerabilities/upload/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: security=low;acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada; PHPSESSID=ij584g37d4f14n6gv872mth7b0; x-s3-sid=&gt;rn`yh6vsgm0dhtp/R1e3v30y; x-s3-rtk=Tr20uent76gJdi1hwE6szylhW524o49eUR4439; x-s3-tid=9c3321c9b97c96f78e8bda2351ef7f34c7250918:ylhW52_Pe3B:190a1755-e092-11ea-8767-5d01a268a33a:ae97f50468</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryhrzKECyteqHqat1e</span><br><span class="line">Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;</span><br><span class="line"></span><br><span class="line">100000</span><br><span class="line">------WebKitFormBoundaryhrzKECyteqHqat1e</span><br><span class="line">Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;test.xml&quot;</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;XMLReport name=&quot;test&quot; xml_export_version=&quot;1.0&quot;&gt;</span><br><span class="line">   &lt;summary&gt;</span><br><span class="line">      &lt;url&gt;http://www.baidu.com/&lt;/url&gt;</span><br><span class="line">      &lt;server_type&gt;None&lt;/server_type&gt;</span><br><span class="line">      &lt;scan_mode&gt;0&lt;/scan_mode&gt;</span><br><span class="line">      &lt;profile_name&gt;...........................&lt;/profile_name&gt;</span><br><span class="line">      &lt;time&gt;</span><br><span class="line">         &lt;scan_begin&gt;2019/04/10 01:39:52&lt;/scan_begin&gt;</span><br><span class="line">         &lt;scan_end&gt;2019/04/10 01:40:23&lt;/scan_end&gt;</span><br><span class="line">         &lt;scan_duration&gt;31s&lt;/scan_duration&gt;</span><br><span class="line">      &lt;/time&gt;</span><br><span class="line">      &lt;total_urls/&gt;</span><br><span class="line">      &lt;total_vulns&gt;</span><br><span class="line">         &lt;total_serious_vulns&gt;0&lt;/total_serious_vulns&gt;</span><br><span class="line">         &lt;total_high_vulns&gt;0&lt;/total_high_vulns&gt;</span><br><span class="line">         &lt;total_medium_vulns&gt;0&lt;/total_medium_vulns&gt;</span><br><span class="line">         &lt;total_low_vulns&gt;0&lt;/total_low_vulns&gt;</span><br><span class="line">      &lt;/total_vulns&gt;</span><br><span class="line">   &lt;/summary&gt;</span><br><span class="line">   &lt;vuln_items/&gt;</span><br><span class="line">   &lt;server_information&gt;</span><br><span class="line">      &lt;host&gt;http://www.baidu.com/&lt;/host&gt;</span><br><span class="line">      &lt;server_type/&gt;</span><br><span class="line">      &lt;total_urls num=&quot;0&quot;/&gt;</span><br><span class="line">      &lt;external_urls num=&quot;0&quot;/&gt;</span><br><span class="line">   &lt;/server_information&gt;</span><br><span class="line">&lt;/XMLReport&gt;</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryhrzKECyteqHqat1e</span><br><span class="line">Content-Disposition: form-data; name=&quot;Upload&quot;</span><br><span class="line"></span><br><span class="line">Upload</span><br><span class="line">------WebKitFormBoundaryhrzKECyteqHqat1e--</span><br></pre></td></tr></table></figure><p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。<br>然后 Content-Type 里指明了数据是以 multipart&#x2F;form-data 来编码，本次请求的 boundary 是什么内容。</p><p>消息主体里按照字段个数又分为多个结构类似的部分，<strong>每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。</strong></p><p>如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</p><p><strong>application&#x2F;x-www-form-urlencoded： 窗体数据被编码为名称&#x2F;值对</strong>。这是标准的编码格式。</p><p><strong>multipart&#x2F;form-data： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分</strong>。 </p><p><strong>text&#x2F;plain： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。</strong></p><blockquote><p>form 的enctype属性为编码方式，常用有两种：</p><p>application&#x2F;x-www-form-urlencoded和multipart&#x2F;form- data，默认为application&#x2F;x-www-form-urlencoded。 </p><p>当action为get时候，浏览器用x-www-form-urlencoded的编码方式把form数据转换成一个字串（name1&#x3D;value1&amp; amp;name2&#x3D;value2…），然后把这个字串append到url后面，用?分割，加载这个新的url。</p><p> 当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 </p><p>如果没有type&#x3D;file的控件，用默认的application&#x2F;x-www-form-urlencoded就可以了。 但是如果有type&#x3D;file的话，就要用到multipart&#x2F;form-data了。浏览器会把整个表单以控件为单位分割，并为每个部分加上 Content-Disposition(form-data或者file),Content-Type(默认为text&#x2F;plain),name(控件 name)等信息，并加上分割符(boundary)。</p></blockquote><h3 id="application-json"><a href="#application-json" class="headerlink" title="application&#x2F;json"></a>application&#x2F;json</h3><p>消息主体是序列化后的JSON字符串</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1  </span><br><span class="line">Content-Type: application/json;charset=utf-8  </span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure><h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text&#x2F;xml"></a>text&#x2F;xml</h3><p>一种使用http作为传输协议，XML作为编码方式的远程调用规范</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST [http://www.example.com](http://www.example.com) HTTP/1.1 </span><br><span class="line">Content-Type: text/xml </span><br><span class="line">&lt;!--?xml version=&quot;1.0&quot;?--&gt; </span><br><span class="line">&lt;methodcall&gt; </span><br><span class="line">    &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; </span><br><span class="line">    &lt;params&gt; </span><br><span class="line">        &lt;param&gt; </span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; </span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt; </span><br><span class="line">&lt;/methodcall&gt; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是content-type&quot;&gt;&lt;a href=&quot;#什么是content-type&quot; class=&quot;headerlink&quot; title=&quot;什么是content-type&quot;&gt;&lt;/a&gt;什么是content-type&lt;/h2&gt;&lt;p&gt;Content-type首部字段说明</summary>
      
    
    
    
    <category term="HTTP" scheme="http://tsung1992.github.io/categories/HTTP/"/>
    
    
    <category term="http" scheme="http://tsung1992.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像</title>
    <link href="http://tsung1992.github.io/docker/docker%E9%95%9C%E5%83%8F/"/>
    <id>http://tsung1992.github.io/docker/docker%E9%95%9C%E5%83%8F/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h2><blockquote><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境的开发软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p></blockquote><h3 id="联合文件系统-unionFS"><a href="#联合文件系统-unionFS" class="headerlink" title="联合文件系统(unionFS)"></a>联合文件系统(unionFS)</h3><p>联合文件系统是一种分层、轻量级并且高性能的文件系统。它支持对文件文件系统的修改作为一次提交来层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p><ul><li>联合文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像</li></ul><h2 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h2><h3 id="什么是docker镜像"><a href="#什么是docker镜像" class="headerlink" title="什么是docker镜像"></a>什么是docker镜像</h3><p>一个完整的docker镜像可以支撑一个docker容器的运行，在docker容器运行过程中主要提供文件系统视角。</p><blockquote><p>插话(理解Linux内核和ubuntu镜像的区别)：</p><p>传统虚拟机安装ubuntu包含两部分：</p><ol><li>某个Linux内核的发行版本，比如Linux3.8版本的内核</li><li>某个特定的Ubuntu发行版，这部分内容不包含Linux内核，但包含Linux之外的软件管理方式、软件驱动。</li></ol></blockquote><h3 id="Docker镜像原理-1"><a href="#Docker镜像原理-1" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h3><h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><ol><li><p>Linux系统一般有内核、shell、文件系统和应用程序共4部分组成。</p></li><li><p>Linux文件系统由bootfs和roorfs两部分组成</p></li></ol><ul><li>bootfs(boot file system)：包含boot loader(引导加载程序)和kernel(内核)。用户不会修改这个文件系统。实际上，在启动(boot)过程完成后，整个内容都会被加载进内存，此时bootfs会被卸载掉从而释放出所占用的内存。同时也可以看出，对于同样内核版本的不同Linux发行版的bootfs都是一致的</li><li>rootfs(root file system)：包含典型的目录结构，包括&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc，&#x2F;lib，&#x2F;usr及&#x2F;tmp等再加上要运行用户应用所需要的所有配置文件，二进制文件和库文件。这个文件系统在不同的Linux发行版中是不同的。而且用户可以对这个文件进行修改。</li></ul><h4 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h4><p>docker镜像实际上由一层一层的文件系统组成（层叠的只读文件系统）</p><p>联合加载(union mount)</p><ul><li>Docker镜像是由特殊的文件系统叠加而成</li><li>最底端是 bootfs，并使用宿主机的bootfs(引导文件系统)</li><li>第二层是 root文件系统rootfs，称为base image（基础镜像）</li><li>然后再往上可以叠加其他的镜像文件</li><li>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</li><li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。</li><li>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><p><img src= "/img/loading.gif" data-lazy-src="/images/1469015-20200424175105871-1045827299.png" alt="img"></p><p>根据镜像原理解决了下面的问题</p><ol><li><p>Docker 镜像本质是什么？</p><ul><li>是一个分层文件系统</li></ul></li><li><p>Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？</p><ul><li>Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层</li></ul></li><li><p>Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？</p><ul><li>由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多MB</li></ul></li><li><p>docker镜像为什么采用这种分层的结构</p><ul><li><p>最大的好处是 ——共享资源</p><blockquote><p>当有多个镜像都从相同的base镜像构建而来时，宿主机只需要在磁盘上保存一份base镜像，同时内存也需要加载一份base镜像，就可以为所有服务器服务了。而且镜像的每一层都可以被共享。</p></blockquote></li></ul></li></ol><h4 id="docker镜像内容"><a href="#docker镜像内容" class="headerlink" title="docker镜像内容"></a>docker镜像内容</h4><p>docker镜像的内容主要包含两部分：</p><ol><li><p>镜像层文件内容</p></li><li><p>镜像json文件</p><blockquote><p>容器是一个动态的环境，每一层镜像中的文件属于静态内容，然而dockerfile中的ENV、VOLUME、CMD等内容最终都需要落实到容器的运行环境中，而这些内容均不可能直接坐落到每一层镜像所包含的文件系统内容中，此时每个docker镜像还会包含json文件记录与容器之间的关系</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是镜像&quot;&gt;&lt;a href=&quot;#什么是镜像&quot; class=&quot;headerlink&quot; title=&quot;什么是镜像&quot;&gt;&lt;/a&gt;什么是镜像&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境的开发软件，它包含</summary>
      
    
    
    
    <category term="docker" scheme="http://tsung1992.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="http://tsung1992.github.io/tags/docker/"/>
    
    <category term="容器" scheme="http://tsung1992.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>初识docker</title>
    <link href="http://tsung1992.github.io/docker/%E5%88%9D%E8%AF%86docker/"/>
    <id>http://tsung1992.github.io/docker/%E5%88%9D%E8%AF%86docker/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2025-07-19T13:45:57.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-历史"><a href="#docker-历史" class="headerlink" title="docker 历史"></a>docker 历史</h2><h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>Docker是基于Go语言实现的开源容器项目，诞生于2013年初，最初的发起者是dotCloud公司。</p><p>Docker是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本。</p><p>Docker的构想是要实现“Build，Ship and Run Any App， Anywhere”，即通过对应用的<code>封装(Packaging)</code>、<code>分发(Distribution)</code>、<code>部署(Deployment)</code>、<code>运行(Runtime)</code>生命周期进行管理，达到应用组件“一次封装、到处运行”的目的。</p><h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h2><ol><li><p>Docker容器化的好处</p><p>通过容器来打包应用、解耦应用和运行平台。</p></li><li><p>Docker在开发和运维中的优势</p><p>(1) 更快速的交付和部署</p><p>(2) 更高效的资源利用</p><p>​    运行docker容器不需要额外的虚拟化管理程序的支持，docker是内核级的虚拟化，可以实现更高的性能，    同时对资源的额外需求较低</p><p>(3) 更轻松的迁移和扩展</p><p>(4) 更简单的更新管理</p><p>​    使用dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作</p></li></ol><h2 id="Docker与虚拟化"><a href="#Docker与虚拟化" class="headerlink" title="Docker与虚拟化"></a>Docker与虚拟化</h2><p>虚拟化技术一般指的是计算机虚拟化，或通常说的服务器虚拟化。</p><p>维基百科如是说：</p><blockquote><p>在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。</p></blockquote><p>虚拟化的核心是对资源的抽象。</p><p>虚拟化技术科分为基于硬件的虚拟化和基于软件的虚拟化。</p><p>基于软件的虚拟化可分为应用虚拟化和平台虚拟化。</p><p>平台虚拟化：</p><blockquote><ol><li>完全虚拟化：虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无须进行修改</li><li>硬件辅助虚拟化：利用硬件(主要是CPU)辅助支持处理敏感指令来实现完全虚拟化的功能，客户操作系统无须修改</li><li>部分虚拟化：只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改</li><li>超虚拟化：部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改</li><li>操作系统级虚拟化：内核通过创建多个虚拟的操作系统实例(内核和库)来隔离不同的进程。(容器相关技术即在这个范畴)</li></ol></blockquote><h3 id="docker为什么比VM快"><a href="#docker为什么比VM快" class="headerlink" title="docker为什么比VM快"></a>docker为什么比VM快</h3><ol><li><p>docker有着比虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在Cpu、内存利用率上Docker将会在效率上有明显优势</p></li><li><p>docker利用宿主机的内核，VM需要是Guest OS</p><p><img src= "/img/loading.gif" data-lazy-src="/images/vm-vs-docker-architecture1.png" alt="img"></p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="/images/image-20200523162048460.png" alt="image-20200523162048460"></p><h2 id="Docker的思想"><a href="#Docker的思想" class="headerlink" title="Docker的思想"></a>Docker的思想</h2><blockquote><ol><li><p>集装箱</p><p>会将所有需要的内容放到不同的集装箱中，所需要的环境直接用这个集装箱就可以了</p></li><li><p>标准化</p><p>(1) 运输的标准化：统一的仓库</p><p>(2) 命令的标准化：docker提供了一系列的命令，帮助我们操作容器</p><p>(3) 提供了REST的API：衍生出了很多的图形化界面</p></li><li><p>隔离性</p><p>docker在运行容器时，会在Linux的内核中，单独开辟空间，该空间不影响其他进程</p></li></ol></blockquote><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p>Docker本身是一个容器运行载体或称之为管理引擎。</p><p>docker三要素：容器，镜像，仓库</p><p><strong>镜像</strong>：用于创建Docker容器的模板，一个镜像可以创建多个容器</p><p><strong>容器</strong>：独立运行的一个或一组应用，是镜像运行的实体</p><p><strong>仓库</strong>：集中存放镜像的地方，分为共有仓库和私有仓库</p><p>最大的公开仓库：<a href="https://hub.docker.com/">https://hub.docker.com</a></p><h3 id="docker的架构图："><a href="#docker的架构图：" class="headerlink" title="docker的架构图："></a>docker的架构图：</h3><p><img src= "/img/loading.gif" data-lazy-src="/images/timg-1593696254912" alt="img"></p><table><thead><tr><th align="left">概念</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Docker 镜像(Images)</td><td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="left">Docker 容器(Container)</td><td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="left">Docker 客户端(Client)</td><td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td align="left">Docker 主机(Host)</td><td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">Docker Registry</td><td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td></tr><tr><td align="left">Docker Machine</td><td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><h2 id="Docker的使用场景"><a href="#Docker的使用场景" class="headerlink" title="Docker的使用场景"></a>Docker的使用场景</h2><ol><li>使用Docker容器开发、测试、部署服务</li><li>创建隔离的运行环境</li><li>搭建测试环境</li><li>构建多用户的平台即服务基础设施</li><li>提供软件即服务应用程序</li><li>高性能、超大规模的宿主机部署</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker-历史&quot;&gt;&lt;a href=&quot;#docker-历史&quot; class=&quot;headerlink&quot; title=&quot;docker 历史&quot;&gt;&lt;/a&gt;docker 历史&lt;/h2&gt;&lt;h2 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; class</summary>
      
    
    
    
    <category term="docker" scheme="http://tsung1992.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="http://tsung1992.github.io/tags/docker/"/>
    
    <category term="容器" scheme="http://tsung1992.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
